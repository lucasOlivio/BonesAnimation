#include "pch.h"
#include "cFileLoader_Imp.h"

//#include <iostream>

#include <assimp/Importer.hpp>      // C++ importer interface
#include <assimp/scene.h>           // Output data structure
#include <assimp/postprocess.h>     // Post processing flags

// Note: Depending on the library, you have to use the specific config.h
// file from the lib folder. This is generated by CMake.
// This config is VS22vc143x64static

#include <sstream>
#include <float.h>
#include <fstream>
#include <glm/vec3.hpp>

namespace MyEngine
{
	void AssimpToGLM(const aiMatrix4x4& a, glm::mat4& g)
	{
		g[0][0] = a.a1; g[0][1] = a.b1; g[0][2] = a.c1; g[0][3] = a.d1;
		g[1][0] = a.a2; g[1][1] = a.b2; g[1][2] = a.c2; g[1][3] = a.d2;
		g[2][0] = a.a3; g[2][1] = a.b3; g[2][2] = a.c3; g[2][3] = a.d3;
		g[3][0] = a.a4; g[3][1] = a.b4; g[3][2] = a.c4; g[3][3] = a.d4;
	}

	void AssimpToGLM(const aiVector3D& a, glm::vec3& g)
	{
		g[0] = a.x;
		g[1] = a.y;
		g[2] = a.z;
	}

	void AssimpToGLM(const aiQuaternion& a, glm::quat& g)
	{
		g[0] = a.w;
		g[1] = a.x;
		g[2] = a.y;
		g[3] = a.z;
	}

	void AssimpToGLM(const aiVector3D& a, float& g)
	{
		g = a.x;
	}

	cFileLoader_Imp::cFileLoader_Imp()
	{

	}

	cFileLoader_Imp::~cFileLoader_Imp()
	{

	}

	Node* cFileLoader_Imp::m_CreateAnimNode(aiNode* node)
	{
		Node* newNode = new Node(node->mName.C_Str());

		aiVector3D position;
		aiQuaternion rotation;
		aiVector3D scaling;
		node->mTransformation.Decompose(scaling, rotation, position);

		AssimpToGLM(node->mTransformation, newNode->transformation);

		return newNode;
	}

	Node* cFileLoader_Imp::m_GenerateBoneHierarchy(aiNode* assimpNode, sMesh* drawInfo, const int depth)
	{
		Node* node = m_CreateAnimNode(assimpNode);
		node->id = static_cast<int>(drawInfo->vecNodes.size());

		drawInfo->vecNodes.push_back(node);

		for (uint i = 0; i < assimpNode->mNumChildren; ++i)
		{
			node->children.push_back(m_GenerateBoneHierarchy(assimpNode->mChildren[i], drawInfo, depth + 1));
		}

		return node;
	}

	bool cFileLoader_Imp::m_ProcessScene(const aiScene* scene, sMesh* drawInfo)
	{
		// TODO: Validation of meshes and diferent objects loading
		for (uint index = 0; index < scene->mNumMeshes; index++)
		{
			aiMesh* currMesh = scene->mMeshes[index];

			// Set basic data for the structure
			drawInfo->numberOfIndices += currMesh->mNumFaces * currMesh->mFaces[0].mNumIndices; // Get # of indices total based on the first face element
			drawInfo->numberOfTriangles += currMesh->mNumFaces;
			drawInfo->numberOfVertices += currMesh->mNumVertices;
		}
		// Load the triangles for organize structure
		drawInfo->pTriangles = new sTriangle[drawInfo->numberOfTriangles];
		// Load the vertices in the opengl structure VBO
		drawInfo->pVertices = new sVertex[drawInfo->numberOfVertices];
		// Load the indices for the Index Buffer
		drawInfo->pIndices = new uint[drawInfo->numberOfIndices];

		float minX = FLT_MAX;
		float minY = minX;
		float minZ = minX;
		float maxX = FLT_MIN;
		float maxY = maxX;
		float maxZ = maxX;
		for (uint index = 0; index < scene->mNumMeshes; index++)
		{
			aiMesh* currMesh = scene->mMeshes[index];

			// Load the vertices in the opengl structure VBO
			for (uint currMeshIndex = 0; currMeshIndex < drawInfo->numberOfVertices; currMeshIndex++)
			{
				uint vboIndex = currMeshIndex + (index * currMeshIndex); // Allocate all in sequence in the array
				drawInfo->pVertices[vboIndex].x = currMesh->mVertices[vboIndex].x;
				drawInfo->pVertices[vboIndex].y = currMesh->mVertices[vboIndex].y;
				drawInfo->pVertices[vboIndex].z = currMesh->mVertices[vboIndex].z;
				drawInfo->pVertices[vboIndex].w = 1.0f;

				// Check if mesh have normals
				if (currMesh->HasNormals())
				{
					drawInfo->pVertices[vboIndex].nx = currMesh->mNormals[vboIndex].x;
					drawInfo->pVertices[vboIndex].ny = currMesh->mNormals[vboIndex].y;
					drawInfo->pVertices[vboIndex].nz = currMesh->mNormals[vboIndex].z;
					drawInfo->pVertices[vboIndex].nw = 1.0f;
				}

				// Check if mesh have vertex colors
				if (currMesh->HasVertexColors(index))
				{
					drawInfo->pVertices[vboIndex].r = currMesh->mColors[index][vboIndex].r;
					drawInfo->pVertices[vboIndex].g = currMesh->mColors[index][vboIndex].g;
					drawInfo->pVertices[vboIndex].b = currMesh->mColors[index][vboIndex].b;
					drawInfo->pVertices[vboIndex].a = currMesh->mColors[index][vboIndex].a;
				}

				// Check if mesh have texture coordinates
				if (currMesh->HasTextureCoords(index))
				{
					drawInfo->pVertices[vboIndex].u = currMesh->mTextureCoords[index][vboIndex].x;
					drawInfo->pVertices[vboIndex].v = currMesh->mTextureCoords[index][vboIndex].y;
				}

				// Get mesh info
				if (drawInfo->pVertices[vboIndex].x < minX)
				{
					minX = drawInfo->pVertices[vboIndex].x;
				}
				if (drawInfo->pVertices[vboIndex].y < minY)
				{
					minY = drawInfo->pVertices[vboIndex].y;
				}
				if (drawInfo->pVertices[vboIndex].z < minZ)
				{
					minZ = drawInfo->pVertices[vboIndex].z;
				}

				if (drawInfo->pVertices[vboIndex].x > maxX)
				{
					maxX = drawInfo->pVertices[vboIndex].x;
				}
				if (drawInfo->pVertices[vboIndex].y > maxY)
				{
					maxY = drawInfo->pVertices[vboIndex].y;
				}
				if (drawInfo->pVertices[vboIndex].z > maxZ)
				{
					maxZ = drawInfo->pVertices[vboIndex].z;
				}
			}

			// Load the indices for the Index Buffer
			// TODO: Load different indices numbers based on shape (For now we just will use triangles)
			for (uint currTriangleIndex = 0;
				currTriangleIndex < drawInfo->numberOfTriangles;
				currTriangleIndex++)
			{
				// Jump every 3 vertex index
				uint indicesIndex = currTriangleIndex * 3;

				int v1 = currMesh->mFaces[currTriangleIndex].mIndices[0];
				int v2 = currMesh->mFaces[currTriangleIndex].mIndices[1];
				int v3 = currMesh->mFaces[currTriangleIndex].mIndices[2];

				drawInfo->pIndices[indicesIndex] = v1;
				indicesIndex += 1;
				drawInfo->pIndices[indicesIndex] = v2;
				indicesIndex += 1;
				drawInfo->pIndices[indicesIndex] = v3;
				indicesIndex += 1;

				// Load vertices positions into triangles
				drawInfo->pTriangles[currTriangleIndex].vertices[0] = glm::vec3(drawInfo->pVertices[v1].x,
					drawInfo->pVertices[v1].y,
					drawInfo->pVertices[v1].z);
				drawInfo->pTriangles[currTriangleIndex].vertices[1] = glm::vec3(drawInfo->pVertices[v2].x,
					drawInfo->pVertices[v2].y,
					drawInfo->pVertices[v2].z);
				drawInfo->pTriangles[currTriangleIndex].vertices[2] = glm::vec3(drawInfo->pVertices[v3].x,
					drawInfo->pVertices[v3].y,
					drawInfo->pVertices[v3].z);
			}

			if (!currMesh->HasBones())
			{
				continue;
			}

			if (scene->mNumAnimations > 0)
			{
				MeshAnimations* pMeshAnimations = new MeshAnimations();
				pMeshAnimations->isActive = true;
				pMeshAnimations->animActive = 0;
				pMeshAnimations->animations.resize(scene->mNumAnimations);

				for (uint i = 0; i < scene->mNumAnimations; i++)
				{
					AnimationInfo animInfo = AnimationInfo();
					aiAnimation* animation = scene->mAnimations[i];

					animInfo.name = animation->mName.C_Str();
					animInfo.duration = static_cast<float>(animation->mDuration);
					animInfo.ticksPerSecond = static_cast<float>(animation->mTicksPerSecond);

					for (uint j = 0; j < animation->mNumChannels; ++j)
					{
						aiNodeAnim* assimpNodeAnim = animation->mChannels[j];
						NodeAnimationInfo nodeAnimInfo = NodeAnimationInfo();
						nodeAnimInfo.name = assimpNodeAnim->mNodeName.C_Str();

						nodeAnimInfo.positionKeyFrames.resize(assimpNodeAnim->mNumPositionKeys);
						for (uint k = 0; k < assimpNodeAnim->mNumPositionKeys; ++k)
						{
							aiVectorKey& p = assimpNodeAnim->mPositionKeys[k];
							PositionKeyFrame posKF = PositionKeyFrame();
							posKF.time = static_cast<float>(p.mTime);
							posKF.value = glm::vec3(p.mValue.x, p.mValue.y, p.mValue.z);
							nodeAnimInfo.positionKeyFrames[k] = posKF;
						}

						nodeAnimInfo.scaleKeyFrames.resize(assimpNodeAnim->mNumScalingKeys);
						for (uint k = 0; k < assimpNodeAnim->mNumScalingKeys; ++k)
						{
							aiVectorKey& s = assimpNodeAnim->mScalingKeys[k];
							ScaleKeyFrame scaKF = ScaleKeyFrame();
							scaKF.time = static_cast<float>(s.mTime);
							scaKF.value = glm::vec3(s.mValue.x, s.mValue.y, s.mValue.z);
							nodeAnimInfo.scaleKeyFrames[k] = scaKF;
						}

						nodeAnimInfo.rotationKeyFrames.resize(assimpNodeAnim->mNumRotationKeys);
						for (uint k = 0; k < assimpNodeAnim->mNumRotationKeys; ++k)
						{
							aiQuatKey& q = assimpNodeAnim->mRotationKeys[k];
							RotationKeyFrame rotKF = RotationKeyFrame();
							rotKF.time = static_cast<float>(q.mTime);
							rotKF.value = glm::quat(q.mValue.w, q.mValue.x, q.mValue.y, q.mValue.z);
							nodeAnimInfo.rotationKeyFrames[k] = rotKF;
						}

						animInfo.channels[nodeAnimInfo.name] = nodeAnimInfo;
					}
					pMeshAnimations->animations[i] = animInfo;
				}

				drawInfo->pMeshAnimations = pMeshAnimations;
			}

			// Loading the vertices bones
			drawInfo->rootNode = m_GenerateBoneHierarchy(scene->mRootNode, drawInfo);

			std::vector<BoneWeightInfo> boneWeights;
			boneWeights.resize(currMesh->mNumVertices);

			uint numBones = currMesh->mNumBones;
			drawInfo->bonesInfo.resize(numBones);

			for (uint boneIdx = 0; boneIdx < numBones; ++boneIdx)
			{
				aiBone* bone = currMesh->mBones[boneIdx];

				std::string name(bone->mName.C_Str());
				drawInfo->boneNameId.insert(std::make_pair(name, boneIdx));

				// Store the offset matrices
				BoneInfo info;
				AssimpToGLM(bone->mOffsetMatrix, info.BoneOffset);
				drawInfo->bonesInfo[boneIdx] = info;

				for (uint weightIdx = 0; weightIdx < bone->mNumWeights; ++weightIdx)
				{
					aiVertexWeight& vertexWeight = bone->mWeights[weightIdx];
					// BoneId		:	boneIdx
					// Vertexid		:	vertexWeight.mVertexId
					// Weight		:	vertexWeight.mWeight

					sVertex& vertex = drawInfo->pVertices[vertexWeight.mVertexId];

					if (vertex.w1 == 0.0f)
					{
						vertex.b1 = static_cast<float>(boneIdx);
						vertex.w1 = vertexWeight.mWeight;
						continue;
					}
					if (vertex.w2 == 0.0f)
					{
						vertex.b2 = static_cast<float>(boneIdx);
						vertex.w2 = vertexWeight.mWeight;
						continue;
					}
					if (vertex.w3 == 0.0f)
					{
						vertex.b3 = static_cast<float>(boneIdx);
						vertex.w3 = vertexWeight.mWeight;
						continue;
					}
					if (vertex.w4 == 0.0f)
					{
						vertex.b4 = static_cast<float>(boneIdx);
						vertex.w4 = vertexWeight.mWeight;
						continue;
					}
				}
			}
		}

		drawInfo->minY = minY;
		drawInfo->minZ = minZ;
		drawInfo->maxX = maxX;
		drawInfo->maxY = maxY;
		drawInfo->maxZ = maxZ;

		return true;
	}

	bool cFileLoader_Imp::Load3DModelFile(std::string filename, cFileLoader::sPostProcessFlags postProcessOptions, sMesh* drawInfo)
	{
		std::string filename_and_path = filename;

		if (this->m_basePath_no_end_slash != "")
		{
			filename_and_path = this->m_basePath_no_end_slash + '/' + filename;
		}

		// Translate the boolean helper flags to the assimp post processing flags
		uint assimpPostProcessingFlags = this->m_loadAssimpPostProcessingFlags(postProcessOptions);

		// This is from the assimp help documentation
		// Create an instance of the Importer class
		Assimp::Importer importer;
		// And have it read the given file with some example postprocessing
		// Usually - if speed is not the most important aspect for you - you'll 
		// propably to request more postprocessing than we do in this example.
		const aiScene* scene = importer.ReadFile(filename_and_path.c_str(), assimpPostProcessingFlags);

		// If the import failed, report it
		if (!scene)
		{
			std::string errorString(importer.GetErrorString());
			this->m_AppendErrorString(errorString);
			return false;
		}
		// Now we can access the file's contents. 

		ass_cScene theScene;
		theScene.scene_flags.DecodeSceneFlags(scene->mFlags);

		this->m_ProcessScene(scene, drawInfo);
		// We're done. Everything will be cleaned up by the importer destructor
		importer.FreeScene();
		return true;
	}

	uint cFileLoader_Imp::m_loadAssimpPostProcessingFlags(cFileLoader::sPostProcessFlags postProcessOptions)
	{
		uint assimpPostProcessingFlags = 0;

		if (postProcessOptions.bProcess_CalcTangentSpace)
		{
			assimpPostProcessingFlags |= aiProcess_CalcTangentSpace;
		}
		if (postProcessOptions.bProcess_CalcTangentSpace)
		{
			assimpPostProcessingFlags |= aiProcess_CalcTangentSpace;
		}
		if (postProcessOptions.bProcess_JoinIdenticalVertices)
		{
			assimpPostProcessingFlags |= aiProcess_JoinIdenticalVertices;
		}
		if (postProcessOptions.bProcess_MakeLeftHanded)
		{
			assimpPostProcessingFlags |= aiProcess_MakeLeftHanded;
		}
		if (postProcessOptions.bProcess_Triangulate)
		{
			assimpPostProcessingFlags |= aiProcess_Triangulate;
		}
		if (postProcessOptions.bProcess_RemoveComponent)
		{
			assimpPostProcessingFlags |= aiProcess_RemoveComponent;
		}
		if (postProcessOptions.bProcess_GenNormals)
		{
			assimpPostProcessingFlags |= aiProcess_GenNormals;
		}
		if (postProcessOptions.bProcess_GenSmoothNormals)
		{
			assimpPostProcessingFlags |= aiProcess_GenSmoothNormals;
		}
		if (postProcessOptions.bProcess_SplitLargeMeshes)
		{
			assimpPostProcessingFlags |= aiProcess_SplitLargeMeshes;
		}
		if (postProcessOptions.bProcess_PreTransformVertices)
		{
			assimpPostProcessingFlags |= aiProcess_PreTransformVertices;
		}
		if (postProcessOptions.bProcess_LimitBoneWeights)
		{
			assimpPostProcessingFlags |= aiProcess_LimitBoneWeights;
		}
		if (postProcessOptions.bProcess_ValidateDataStructure)
		{
			assimpPostProcessingFlags |= aiProcess_ValidateDataStructure;
		}
		if (postProcessOptions.bProcess_ImproveCacheLocality)
		{
			assimpPostProcessingFlags |= aiProcess_ImproveCacheLocality;
		}
		if (postProcessOptions.bProcess_RemoveRedundantMaterials)
		{
			assimpPostProcessingFlags |= aiProcess_RemoveRedundantMaterials;
		}
		if (postProcessOptions.bProcess_FixInfacingNormals)
		{
			assimpPostProcessingFlags |= aiProcess_FixInfacingNormals;
		}
		if (postProcessOptions.bProcess_SortByPType)
		{
			assimpPostProcessingFlags |= aiProcess_SortByPType;
		}
		if (postProcessOptions.bProcess_FindDegenerates)
		{
			assimpPostProcessingFlags |= aiProcess_FindDegenerates;
		}
		if (postProcessOptions.bProcess_FindInvalidData)
		{
			assimpPostProcessingFlags |= aiProcess_FindInvalidData;
		}
		if (postProcessOptions.bProcess_GenUVCoords)
		{
			assimpPostProcessingFlags |= aiProcess_GenUVCoords;
		}
		if (postProcessOptions.bProcess_TransformUVCoords)
		{
			assimpPostProcessingFlags |= aiProcess_TransformUVCoords;
		}
		if (postProcessOptions.bProcess_FindInstances)
		{
			assimpPostProcessingFlags |= aiProcess_FindInstances;
		}
		if (postProcessOptions.bProcess_OptimizeMeshes)
		{
			assimpPostProcessingFlags |= aiProcess_OptimizeMeshes;
		}
		if (postProcessOptions.bProcess_OptimizeGraph)
		{
			assimpPostProcessingFlags |= aiProcess_OptimizeGraph;
		}
		if (postProcessOptions.bProcess_FlipUVs)
		{
			assimpPostProcessingFlags |= aiProcess_FlipUVs;
		}
		if (postProcessOptions.bProcess_FlipWindingOrder)
		{
			assimpPostProcessingFlags |= aiProcess_FlipWindingOrder;
		}
		if (postProcessOptions.bProcess_SplitByBoneCount)
		{
			assimpPostProcessingFlags |= aiProcess_SplitByBoneCount;
		}
		if (postProcessOptions.bProcess_Debone)
		{
			assimpPostProcessingFlags |= aiProcess_Debone;
		}

		return assimpPostProcessingFlags;
	}


	std::string cFileLoader_Imp::getLastError(bool bAndClearErrors /*=true*/)
	{
		std::string error = this->m_LastError;

		if (bAndClearErrors)
		{
			this->m_LastError = "";
		}
		return error;
	}

	void cFileLoader_Imp::m_AppendErrorString(std::string errorString)
	{
		std::stringstream ssError;
		if (!this->m_LastError.empty())
		{
			ssError << this->m_LastError;
			ssError << std::endl;
		}
		ssError << errorString;
		this->m_LastError = ssError.str();
		return;
	}


	void cFileLoader_Imp::SetBasePath(std::string basepath_no_end_slash)
	{
		this->m_basePath_no_end_slash = basepath_no_end_slash;
		return;
	}
}
